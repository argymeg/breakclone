#' @import ggplot2
#' @import ComplexHeatmap
#' @import ggpubr
#' @import ggrastr
#' @import data.table
#' @import GenomicRanges
#' @import grid
#' @import IRanges

#' @title Plot the reference and pair distributions.
#'
#' @param reference A reference distribution generated by one of the reference functions.
#' @param results A results table generated by one of the relatedness functions.
#' @export
plotScoresDensity <- function(reference, results){
  names(reference) <- rep("Reference", length(reference))
  pair_scores <- results$pair_scores
  names(pair_scores) <- rep("Pairs", length(pair_scores))
  toplot <- as.data.table(c(pair_scores, reference), keep.rownames = TRUE)
  names(toplot) <- c("Distribution", "Score")
  plot <- ggplot(toplot, aes(x = Score, colour = Distribution)) + geom_density(size = 1) + scale_colour_brewer(palette = "Set1") +
    geom_hline(yintercept = 0, size = 1) + geom_vline(xintercept = 0, size = 1) + geom_vline(xintercept = quantile(reference, probs = 0.95), size = 0.5, linetype = 2) + ylab("Density")
  return(plot)
}


#' @title Plot the reference and pair histograms.
#'
#' @param reference A reference distribution generated by one of the reference functions.
#' @param results A results table generated by one of the relatedness functions.
#' @export
plotScoresHistogram <- function(reference, results){
  names(reference) <- rep("Reference", length(reference))
  pair_scores <- results$pair_scores
  names(pair_scores) <- rep("Pairs", length(pair_scores))
  toplot <- as.data.table(c(pair_scores, reference), keep.rownames = TRUE)
  names(toplot) <- c("Distribution", "Score")
  plot <- ggplot(toplot, aes(x = Score, fill = Distribution, y = ..density..)) + geom_histogram(position = "dodge", binwidth = 0.05) + scale_color_brewer(palette = "Set1") +
    geom_hline(yintercept = 0, size = 1) + geom_vline(xintercept = 0, size = 1) + scale_x_continuous(limits = c(-0.1,1.1), breaks = seq(0,1,0.1), expand = expand_scale()) + ylab("Density")
  return(plot)
}

plotCN <- function(tmp, limits, color, chrLims = NULL, bincytoend = NULL, cnColumn = NULL, segColumn = NULL, title=NULL, fontLabelSize, yaxis = "Log2 Ratio", build = c('hg38', 'hg19')){
  build <- match.arg(build)
  if(is.null(chrLims)) { chrLims <- getChrLims(template) }
  if(is.null(bincytoend)) { bincytoend <- getCentromereLims(template, build, chrLims)}
  
  colnames(tmp)[colnames(tmp)==cnColumn] <- 'cnColumn'
  colnames(tmp)[colnames(tmp)==segColumn] <- 'segColumn'
  
  p <- ggplot() +
    scale_y_continuous(name = yaxis, limits = c(limits[1],limits[2]), breaks = seq(limits[1], limits[2], 0.5), expand=c(0.01,0.01)) +
    scale_x_continuous(name = "Chromosome", limits = c(0,tail(chrLims[[3]],1)), breaks = chrLims[[2]], labels = chrLims[[1]]$values, expand = c(0,0)) +
    geom_vline(xintercept = chrLims[[3]], color = "#666666", linetype = "solid",size=0.2) +
    geom_vline(xintercept = bincytoend, color = "#666666", linetype = "dashed" ,size=0.2 ) +
    geom_point_rast(aes(x=bin, y=cnColumn), data = na.omit(tmp), color = color, shape = ".", raster.dpi=300) +
    geom_point_rast(aes(x=bin, y=segColumn), data = na.omit(tmp), color = "black", size=0.1, raster.dpi=300) +
    theme_classic() + 
    theme(
      axis.line = element_line(color='black', size=0.2),
      axis.ticks = element_line(color='black', size=0.2),
      axis.text.y = element_text(color='black', size = fontLabelSize),
      axis.text.x = element_text(color="black", size = fontLabelSize, angle = 90),                
      axis.title.y = element_text(color = "black", size = fontLabelSize),               
      axis.title.x = element_text(color = "black", size = fontLabelSize),
      panel.border = element_rect(color = "black", fill=NA, size=0.2)) + labs(title=title)
  return(p)
}

HeatmapCNPairs <- function(callMat, brkMat, colors, colorsCN, fontLabelSize){
  ht <- Heatmap(callMat,
                use_raster = T,
                col = colorsCN,
                na_col = "white",
                name = 'Aberration',
                border = T,
                show_parent_dend_line = F,
                cluster_columns=F,
                column_order = 1:ncol(callMat),
                cluster_row_slices = F,
                row_order = 1:nrow(callMat),
                row_split = c("A", "B"),
                row_title = NULL,
                column_title_side = "top",
                show_column_names = F,
                column_title_gp = gpar(fontsize = fontLabelSize),
                column_title_rot = 90,
                column_gap=unit(0, "cm"),
                column_split = factor(as.vector(unlist(data.frame(chrom = gsub("\\:.*", "", colnames(callMat))))), levels = c(1:22, "X")),
                show_row_names = F,
                height = nrow(callMat)*unit(6, "mm"),
                bottom_annotation = HeatmapAnnotation(Shared_break = brkMat,
                                                      col = list(Shared_break = c("Shared breakpoint" = "black")),
                                                      na_col = "white",
                                                      height = unit(0.4, "cm"),
                                                      annotation_label = c(" "),
                                                      show_legend = F,
                                                      simple_anno_size_adjust = TRUE,
                                                      show_annotation_name = FALSE),
                left_annotation = rowAnnotation(Sample = c("s1", "s2"),
                                                col = list(Sample = c("s1" = colors[1], "s2" = colors[2])),
                                                width = unit(0.8, "cm"),
                                                show_annotation_name = F,
                                                show_legend = F,
                                                simple_anno_size_adjust = T),
                show_heatmap_legend = F)

  return(ht)
}

getChrLims <- function(template){
  rlechr <- rle(as.vector(template$chr))
  binchrend <- c()
  currentbin <- 0
  binchrmdl <- c()
  for (i in seq_along(rlechr$values)) {
    currentmiddle <- currentbin+rlechr$lengths[i]/2
    currentbin <- currentbin+rlechr$lengths[i]
    binchrend <- append(binchrend, currentbin) 
    binchrmdl <- append(binchrmdl, currentmiddle) 
  }
  
  return(list(rlechr, binchrmdl, binchrend))
}

getCentromereLims <- function(template, build, chrLims = NULL){
  if(is.null(chrLims)) { chrLims <- getChrLims(template)}
  cytobands <- fread(paste0("http://hgdownload.cse.ucsc.edu/goldenpath/", build,"/database/cytoBand.txt.gz")) #download cytoband details from UCSC    cytobands[[1]] <- gsub("chr","",cytobands[[1]])
  cytobands[[1]] <- gsub('chr', '', cytobands[[1]])
  cytobands <- cytobands[cytobands[[1]] %in% as.character(unique(template$chr)),]
  cytobands[[4]] <- gsub("[[:punct:]]", "", gsub('[0-9]+', "",as.character(cytobands[[4]])))
  positions <- c()
  for ( i in chrLims[[1]]$values ){
    tmp <- cytobands[cytobands[[1]] == i,]
    tmp.p <- tmp[tmp[[4]] == "p",]
    p = max(tmp.p[,3])
    positions <- c(positions, p)
  }
  bincytoend <- c()
  for (i in 1:length(positions)){
    bincytoend <- c(bincytoend, which(template$chr == i & template$start <= positions[i] & template$end >= positions[i])) 
  }
  
  return(bincytoend)
}

buildtmpGR <- function(template, segmentTable, pair){
  templateGR <- makeGRangesFromDataFrame(template, keep.extra.columns = T)
  callTableGR <- makeGRangesFromDataFrame(segmentTable[segmentTable$SampleID==pair[1],], keep.extra.columns = T)
  
  overlaps <- findOverlaps(templateGR, callTableGR)
  copy_numbers <- callTableGR$SVType[subjectHits(overlaps)]
  
  templateGR$call_sample1 <- NA
  templateGR[queryHits(overlaps)]$call_sample1 <- copy_numbers
  
  callTableGR <- makeGRangesFromDataFrame(segmentTable[segmentTable$SampleID==pair[2],], keep.extra.columns = T)
  
  overlaps <- findOverlaps(templateGR, callTableGR)
  copy_numbers <- callTableGR$SVType[subjectHits(overlaps)]
  
  templateGR$call_sample2 <- NA
  templateGR[queryHits(overlaps)]$call_sample2 <- copy_numbers
  
  return(templateGR)
}

buildbrkMat <- function(breaks, pair, segmentTable, callMat, templateGR, cnType = c('alleleSpecific', 'VCF'), maxgap, excludeChromosomes, sharedBarSize=30){
  if(is.null(breaks)) {
    brk <- exportSharedBreaks(pair, segmentTable, cnType = cnType, save=FALSE, maxgap = maxgap)
  } else {
    brk <- as.data.table(breaks[[paste0(pair[1], '-', pair[2])]])
  }
  
  brk <- brk[!excludeChromosomes, on = "seqnames"]
  
  brk$start <- ifelse(brk$break_shared=='end', brk$end, brk$start)
  brk$end <- ifelse(brk$break_shared=='start', brk$start, brk$end)
  brkGR <- makeGRangesFromDataFrame(brk, keep.extra.columns = T)
  overlaps <- as.data.table(subsetByOverlaps(templateGR, brkGR))[['region']]
  
  brkMat <- rep(NA, ncol(callMat))
  names(brkMat) <- colnames(callMat)
  brkMat[as.vector(outer(which(names(brkMat)%in%overlaps), 0:sharedBarSize, "+"))] <- 'Shared breakpoint'
  brkMat <- brkMat[1:ncol(callMat)]
  return(brkMat)
}

#' Plot a VCF copy number pair with breakpoints. 
#' 
#' @param binnedTable A segmented copy number matrix with bins per row and samples per column.
#' @param cnTable A raw copy number matrix with bins per row and samples per column.
#' @param pair A character vector with sample1 and sample2 IDs. 
#' @param segmentTable A segment table generated by the breakclone::readAlleleSpecific or breakclone::readVCFCn functions. Also a list with a segment table of each type to plot both kind of data together.
#' @param breaks List of shared breakpoints per pair It will generate a tsv file per pair in outdir with shared breakpoints. 
#' @param colors A character vector with colors for sample 1 and sample 2. 
#' @param limits A numeric vector with y axis limits.
#' @param build The genome build of your copy number data. hg19 and hg38 work, other builds haven't been tested.
#' @param excludeChromosomes The name(s) of any chromosomes to be excluded.
#' @param fontLabelSize Number indicating size of the labels.
#' @param maxgap The maximum gap between two breakpoints for them to be considered concordant. If unspecified, it is automatically set to 5 times the average interprobe distance of the assay.
#' @param sharedBarSize Width of the shared breakpoints bars.
#' @return Copy number plot. 
#' @export
plotCNpairVCF <- function(binnedTable, cnTable, pair, segmentTable, breaks = NULL, colors = c("#f1562f", "#8a4e97"), limits = c(-1.5, 2), build = c('hg38', 'hg19'), excludeChromosomes = 'Y', fontLabelSize = 7, maxgap = NULL, sharedBarSize = 30){
  build <- match.arg(build)
  message('Using genome build ', build)
  
  segmentTable <- segmentTable[!excludeChromosomes, on = "Chr"]

  template <- data.table(region = rownames(binnedTable), 
                         chr = gsub("\\:.*", "", rownames(binnedTable)),
                         start = as.integer(gsub("\\-.*","",gsub(".*:","", rownames(binnedTable)))), 
                         end = as.integer(gsub(".*-","", rownames(binnedTable))),
                         copynumber_sample1 = as.numeric(cnTable[,pair[1]]), 
                         segs_sample1 = as.numeric(binnedTable[,pair[1]]), 
                         copynumber_sample2 = as.numeric(cnTable[,pair[2]]), 
                         segs_sample2 = as.numeric(binnedTable[,pair[2]]),
                         bin = rep(1:nrow(binnedTable)))
  template <- template[!excludeChromosomes, on = "chr"]
    
  #define chromosome and centromere limits
  chrLims <- getChrLims(template)
  bincytoend <- getCentromereLims(template, build, chrLims)
 
  # build callMat
  templateGR <- buildtmpGR(template, segmentTable, pair)
    
  callMat <- t(as.matrix(data.frame(sample1=as.data.table(templateGR)[['call_sample1']], sample2=as.data.table(templateGR)[['call_sample2']])))
  rownames(callMat) <- pair
  colnames(callMat) <- as.data.table(templateGR)[['region']]
    
  # color annotation for cnas
  colorsCN <- structure(c("#b2182b", "#2166ac"), names = c('DUP', 'DEL'))
  
  # build brkMat
  brkMat <- buildbrkMat(breaks, pair, segmentTable, callMat, templateGR, cnType, maxgap, excludeChromosomes, sharedBarSize)

  #segmented plot 
  p1 <- plotCN(tmp=template, limits, color=colors[1], chrLims, bincytoend, cnColumn = 'copynumber_sample1', segColumn = 'segs_sample1', title = pair[1], fontLabelSize, build = build)
  p2 <- plotCN(tmp=template, limits, color=colors[2], chrLims, bincytoend, cnColumn = 'copynumber_sample2', segColumn = 'segs_sample2', title = pair[2], fontLabelSize, build = build)
  
  #oncoplot
  p3 <- grid.grabExpr(draw(HeatmapCNPairs(callMat, brkMat, colors, colorsCN, fontLabelSize)))
  
  # grid
  grid <- ggarrange(p1, p2, p3, ncol = 1, nrow = 3)
  
  return(grid)
}

#' Plot a alleleSpecific copy number pair with breakpoints. 
#'
#' @param ASCATobj ASCATobj an ASCAT object (e.g. from ascat.aspcf)
#' @param segmentTable A segment table generated by the readAlleleSpecific or readVCFCn functions.
#' @param pair A character vector with sample1 and sample2 IDs. 
#' @param breaks List of shared breakpoints per pair It will generate a tsv file per pair in outdir with shared breakpoints. 
#' @param colors A character vector with colors for sample 1 and sample 2. 
#' @param limits A numeric vector with y axis limits.
#' @param build The genome build of your copy number data. hg19 and hg38 work, other builds haven't been tested.
#' @param excludeChromosomes The name(s) of any chromosomes to be excluded.
#' @param fontLabelSize Number indicating size of the labels.
#' @param maxgap The maximum gap between two breakpoints for them to be considered concordant. If unspecified, it is automatically set to 5 times the average interprobe distance of the assay.
#' @param sharedBarSize Width of the shared breakpoints bars.
#' @return Copy number plot.
#' @export
plotCNpairalleleSpecific <- function(ASCATobj, segmentTable, pair, breaks = NULL, colors = c("#f1562f", "#8a4e97"), limits = c(-1.5, 2), build = c('hg38', 'hg19'), excludeChromosomes = 'Y', fontLabelSize = 7, maxgap = NULL, sharedBarSize=30){
  build <- match.arg(build)
  message('Using genome build ', build)
  
  arraynr_s1 <- which(ASCATobj$samples==pair[1])
  arraynr_s2 <-  which(ASCATobj$samples==pair[2])
  template <- data.table(region = paste0(ASCATobj$SNPpos$chrs, ":", ASCATobj$SNPpos$pos, '-', ASCATobj$SNPpos$pos), 
                         chr = factor(ASCATobj$SNPpos$chrs, levels = c(1:22, 'X', 'Y')),
                         start = ASCATobj$SNPpos$pos, 
                         end = ASCATobj$SNPpos$pos+1, 
                         copynumber_sample1 = ASCATobj$Tumor_LogR[,arraynr_s1], 
                         segs_sample1 = ASCATobj$Tumor_LogR_segmented[,arraynr_s1], 
                         copynumber_sample2 = ASCATobj$Tumor_LogR[,arraynr_s2], 
                         segs_sample2 =  ASCATobj$Tumor_LogR_segmented[,arraynr_s2],
                         snp = rownames(ASCATobj$Tumor_BAF),
                         bin = 1:nrow(ASCATobj$SNPpos))
  rownames(template) <- template$snp
  template <- template[!excludeChromosomes, on = "chr"]
  template <- template[order(chr, start),]
  
  #define chromosome and centromere limits
  chrLims <- getChrLims(template)
  bincytoend <- getCentromereLims(template, build, chrLims)
  
  # call cnas
  sample1 <- callalleleSpecificCN(segmentTable[segmentTable$SampleID == pair[1],])
  sample2 <- callalleleSpecificCN(segmentTable[segmentTable$SampleID == pair[2],])
  
  sample1_ploidy <- calculatePloidy(sample1)
  sample2_ploidy <- calculatePloidy(sample2)
  
  segmentTable <- rbind(sample1, sample2)
  
  # build callMat
  templateGR <- buildtmpGR(template, segmentTable, pair)
  
  callMat <- t(as.matrix(data.frame(sample1=as.data.table(templateGR)[['call_sample1']], sample2=as.data.table(templateGR)[['call_sample2']])))
  rownames(callMat) <- pair
  colnames(callMat) <- as.data.table(templateGR)[['region']]
  
  # color annotation for cnas
  colorsCN <- structure(c("#b2182b", '#f4a582', "#2166ac", '#92c5de'), names = c('amp', 'gain', 'loss', 'cnloh'))
  
  # build brkMat
  brkMat <- buildbrkMat(breaks, pair, segmentTable, callMat, templateGR, cnType, maxgap, excludeChromosomes, sharedBarSize)

  # segmented plot
  p1 <- plotCN(template, color = colors[1], limits = limits, chrLims, bincytoend, cnColumn = 'copynumber_sample1', segColumn = 'segs_sample1', title = paste0(pair[1], ', Ploidy ', round(sample1_ploidy, 1)), fontLabelSize)
  p3 <- plotCN(template, color = colors[2], limits = limits, chrLims, bincytoend, cnColumn = 'copynumber_sample2', segColumn = 'segs_sample2', title = paste0(pair[2], ', Ploidy ', round(sample2_ploidy, 1)), fontLabelSize)
  
  # oncoplot
  p5 <- grid.grabExpr(draw(HeatmapCNPairs(callMat, brkMat, colors, colorsCN, fontLabelSize)))
  
  # grid
  grid <- ggarrange(p1, p3, p5, ncol = 1, nrow = 3)
  
  return(grid)
}

#' Plot stacked barplot of total, shared and non-shared breakpoints/mutations and breakclone score per sample.
#' 
#' @param summary A data frame listing the clonality results \code{clonalityResults}, clonality verdict based on the thresholds and number and fraction of shared and private breakpoints per sample.
#' @param sortBy Stacked barplot will be sorted by these columns in summary. By default: verdict and fraction_shared.
#' @param colors A character vector with colors for private in sample 1, in sample 2 and shared breakpoints/mutations.
#' @param colorClonality A character vector with colors for related, ambiguous and unrelated samples.
#' @param colorScore Color of breakclone score bars.
#' @param colorN Color for number of total breakpoints/mutations bars.
#' @param patients A character vector of patient IDs, parallel to the pairs table, used to prevent tumours originating from the same patient from being used in the reference distribution (optional).
#' @param delimiter A character separating patient IDs from tumour-specific identifiers in the sample IDs. Ignored if \code{patients} is provided (optional).
#' @param extraAnno A character vector with annotation of patients. e.g. Invasive or DCIS.
#' @param colorsExtraAnno A named color vector for the extra pheno bar.
#' @param sample1 Label for samples 1.
#' @param sample2 Label for samples 1.
#' @return Summary plot.
#' @export
plotSummary <- function(summary, sortBy=c('verdict', 'fraction_shared'), colors = c("#3987bb", "#aee7ea", '#0c0d0c'), colorClonality = c("#f5c61a", "#fb4f14", "#660c21"), colorScore = '#b48c9c', colorN = 'grey50', patients = NULL, delimiter = NULL, extraAnno = NULL, colorsExtraAnno = NULL, sample1 = 'Primary', sample2 = 'Recurrence'){
  if(is.null(patients) & is.null(delimiter)){
    patients <- as.character(seq(1, nrow(summary)))
  } else if(is.null(patients)){
    p1 <- sapply(strsplit(summary$Sample1, delimiter), "[", 1)
    p2 <- sapply(strsplit(summary$Sample2, delimiter), "[", 1)
    if(all(p1 == p2)){
      patients <- p1
    } else {
      stop("Autodetecting patient IDs failed!")
    }
  }
  
  summary <- summary[order(summary[,sortBy[1]], summary[,sortBy[2]]),]
  mat <- as.matrix(data.frame(sample1 = summary$fraction_private_sample1, sample2 = summary$fraction_private_sample2, shared = summary$fraction_shared))
  row.names(mat) <- patients
  
  l1 <- Legend(title = "Type", labels = c("All", "Shared", paste0(sample1, " private"), paste0(sample2, " private") ), legend_gp = gpar(fill = c(colorN, colors[3], colors[1], colors[2])),legend_height = unit(0.4, "cm") )
  l2 <- Legend(title = "", labels = "Breakclone score", legend_gp = gpar(fill = colorScore),legend_height = unit(0.4, "cm"))
  l3 <- Legend(title = "Clonality", labels = c("Related", "Ambiguous", "Unrelated"), legend_gp = gpar(fill = colorClonality),legend_height = unit(0.4, "cm"))
  
  if(is.null(extraAnno)){
    ha_list <-  
      HeatmapAnnotation(n = anno_barplot(summary$total, gp = gpar(fill = colorN, col = colorN), height = unit(1.7, "cm"), border = FALSE),
                        annotation_name_rot = 90,
                        annotation_name_side = "left",
                        annotation_name_gp = gpar(fontsize = 8) ) %v% 
      HeatmapAnnotation(stacked = anno_barplot(mat, gp = gpar(fill = colors, col = colors, border = NA),  height = unit(1.9, "cm"), border = FALSE),
                        show_annotation_name = FALSE) %v%
      HeatmapAnnotation(" " = anno_barplot(summary$pair_scores,
                                           gp = gpar(fill = colorScore, col = colorScore, border = NA, lty = "blank"), height = unit(1.7, "cm"), border = FALSE),
                        annotation_name_rot = 90,
                        annotation_name_side = "left",
                        annotation_name_gp = gpar(fontsize = 8) ) %v%
      HeatmapAnnotation(relatedness = summary$verdict,
                        " " = extraAnno,
                        col = list(relatedness = c("Related" = colorClonality[1], "Ambiguous" = colorClonality[2], "Unrelated" = colorClonality[3])),
                        show_annotation_name = FALSE,
                        border = TRUE,
                        show_legend = FALSE,
                        simple_anno_size = unit(0.35, "cm") ) %v%
      HeatmapAnnotation(id = anno_text(gt_render(rownames(mat), gp = gpar (fontsize = 7))))
   
    draw(ha_list, heatmap_legend_list = list(l1, l2, l3))
    
  } else {
    if (is.null(colorsExtraAnno)){
      stop("colorsExtraAnno is missing!")
    }
    
    ha_list <-  
      HeatmapAnnotation(n = anno_barplot(summary$total, gp = gpar(fill = colorN, col = colorN), height = unit(1.7, "cm"), border = FALSE),
                        annotation_name_rot = 90,
                        annotation_name_side = "left",
                        annotation_name_gp = gpar(fontsize = 8) ) %v% 
      HeatmapAnnotation(stacked = anno_barplot(mat, gp = gpar(fill = colors, col = colors, border = NA), height = unit(1.9, "cm"), border = FALSE),  
                        show_annotation_name = FALSE) %v%
      HeatmapAnnotation(" " = anno_barplot(summary$pair_scores,
                                           gp = gpar(fill = colorScore, col = colorScore, border = NA, lty = "blank"), height = unit(1.7, "cm"), border = FALSE),
                        annotation_name_rot = 90,
                        annotation_name_side = "left",
                        annotation_name_gp = gpar(fontsize = 8) ) %v%
      HeatmapAnnotation(relatedness = summary$verdict,
                        ' ' = extraAnno,
                        col = list(relatedness = c("Related" = colorClonality[1], "Ambiguous" = colorClonality[2], "Unrelated" = colorClonality[3]),
                                   ' ' = colorsExtraAnno),
                        show_annotation_name = FALSE,
                        border = TRUE,
                        show_legend = FALSE,
                        simple_anno_size = unit(0.35, "cm") ) %v%
      HeatmapAnnotation(id = anno_text(gt_render(rownames(mat), gp = gpar (fontsize = 7))))
    
    l4 <- Legend(title = "", labels = names(colorsExtraAnno), legend_gp = gpar(fill = colorsExtraAnno),legend_height = unit(0.4, "cm"))
    draw(ha_list, heatmap_legend_list = list(l1, l2, l3, l4))
  }
}


#' VAF scatter plot for mutations in a pair.
#' 
#' @param mutationTable A table of mutations in each sample and their allele frequencies. 
#' @param pair A segment table generated by the breakclone::readAlleleSpecific or breakclone::readVCFCn functions. Also a list with a segment table of each type to plot both kind of data together.
#' @param title A character vector with the directory to the shared breakpoints exported with exportSharedBreaks() function.
#' @param xlab A numeric character vector with the bin size.
#' @param ylab The type of copy number data provided. Currently supported options are a custom allele specific data format, and standard copy number VCF files.
#' @param colors A named color vector for private in sample 1, in sample 2 and shared breakpoints/mutations.
#' @param fontLabelSize Number indicating size of the labels.
#' @param dotSize Size of the dots. 
#' @param annotGenes FALSE by default. TRUE if you want to make dot annotation. Extra column needs to be added to mutationTable if this is TRUE.
#' @param fontAnnotSize #' @param fontLabelSize Number indicating size of the annotated text.
#' @param scaleAFs Scale AFs per-sample by the highest AF within each sample. Only recommended for data with significant normal contamination that you are confident contains at least one clonal mutation per sample.
#' @return Mutation plot.
#' @export
plotScatterVAF <- function(mutationTable, pair, title = '', xlab = 'Primary', ylab = 'Recurrence', colors = setNames(c("#3987bb", "#aee7ea", '#0c0d0c'), c(paste0(xlab, ' private'), paste0(ylab, ' private'), 'Shared')), fontLabelSize = 7, limits = c(0, 1), dotSize = 2, annotGenes = FALSE, fontAnnotSize = 3, scaleAFs  = FALSE){
    if (isTRUE(annotGenes) & !('annotation' %in% colnames(mutationTable))){
      stop("annotation column missing in mutationTable")
    } else if (isFALSE(annotGenes)){
      mutationTable$annotation <- ''
    }
  
    sample1 <- mutationTable[mutationTable$SampleID == pair[1],]
    sample2 <- mutationTable[mutationTable$SampleID == pair[2],]
  
    hits <- getHitMut(sample1, sample2, pair, scaleAFs)
      
    if (length(hits[[1]])>0){
      shared <- data.table(sample1 = as.data.table(hits[[1]])[['AF']], sample2 = as.data.table(hits[[2]])[['AF']], Type = 'Shared', annotation = as.data.table(hits[[1]])[['annotation']])
    } else {
      shared <- data.table(sample1 = numeric(), sample2 = numeric(), Type= character(), annotation = character())
    }
      
    if (length(hits[[3]])>0){
      private_sample1 <- data.table(sample1 = as.data.table(hits[[3]])[['AF']], sample2 = rep(0, length(hits[[3]])), Type = paste0(xlab, ' private'), annotation = as.data.table(hits[[3]])[['annotation']])
    } else {
      private_sample1 <- data.table(sample1 = numeric(), sample2 = numeric(), Type= character(), annotation = character())
    }
      
    if (length(hits[[4]])>0){
      private_sample2 <- data.table(sample1 = rep(0, length(hits[[4]])), sample2 = as.data.table(hits[[4]])[['AF']], Type = paste0(ylab, ' private'), annotation = as.data.table(hits[[4]])[['annotation']])
    } else {
      private_sample2 <- data.table(sample1 = numeric(), sample2 = numeric(), Type= character(), annotation = character())
    }
      
    data <- rbind(shared, private_sample1, private_sample2)
      
    p <- ggplot(data, aes(x=sample1, y=sample2, fill = Type, colour = Type))  + 
      geom_point(shape = 21, size = dotSize, aes(fill = Type, colour = Type)) + 
      scale_color_manual(values=colors) +
      scale_fill_manual(values=colors) +
      ggtitle(title) + 
      xlab(xlab) + ylab(ylab) +
      theme(panel.grid = element_blank(), panel.background = element_rect(fill = "white", colour = "black"), 
            axis.text=element_text(size=fontLabelSize),
            axis.title=element_text(size=fontLabelSize),
            legend.key=element_rect(fill="white"),
            legend.text = element_text(size=fontLabelSize),
            legend.title=element_blank()) + 
      xlim(limits) + 
      ylim(limits) 
    
    if(isTRUE(annotGenes)){
      p <- p + geom_text(aes(label = annotation), check_overlap = TRUE, nudge_x = dotSize*0.01, nudge_y = dotSize*0.01,  size=fontAnnotSize, show.legend = FALSE)
    }
    
    return(p)
}